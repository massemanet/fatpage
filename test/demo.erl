%%% This file was generated by fatpage from test/demo.abnf.
%%% It happened on 2023-01-12, at 10:31:12. It was a Thursday.
%%% You should probably not modify it.

-module(demo).

-export([file/1, string/1]).

file(Filename) -> file(Filename, fun '-file-'/1).

string(String) -> string(String, fun '-file-'/1).

'-file-'(Obj) -> repeat(0, inf, fun '-unicodeish-eol-'/1, Obj).

'-unicodeish-eol-'(Obj) ->
    case sequence([fun '-runicodeish-'/1, fun '-eol-'/1], Obj) of
        {ok, [Y1, _], O} -> {ok, Y1, O};
        Err -> Err
    end.

'-runicodeish-'(Obj) -> repeat(0, inf, fun '-unicodeish-'/1, Obj).

'-eol-'(Obj) -> alternative([fun '-CR-'/1, fun '-EOF-'/1], Obj).

'-unicodeish-'(Obj) ->
    alternative([fun (O) -> final(<<33>>, O) end,
                 fun (O) -> final({<<35>>, <<43>>}, O) end,
                 fun (O) -> final({<<45>>, <<126>>}, O) end,
                 fun (O) -> final({<<194, 128>>, <<223, 191>>}, O) end,
                 fun (O) -> final({<<224, 160, 128>>, <<239, 191, 191>>}, O) end,
                 fun (O) -> final({<<240, 144, 128, 128>>, <<244, 143, 191, 191>>}, O) end],
                Obj).

'-CR-'(Obj) ->
    case peek_chars(Obj, 1) of
        {C, 1} when <<$\n>> =:= C -> {ok, C, bump_ptr(Obj, 1)};
        {C, 1} -> {error, {miss, cr, C}};
        Err -> Err
    end.

'-EOF-'(#{ptr := Ptr, sz := Sz} = Obj) ->
    if Sz == Ptr -> {ok, eof, Obj#{ptr => eof}};
       Ptr < Sz -> {error, not_eof};
       true -> {error, past_eof}
    end.

alternative(_, #{ptr := eof}) -> {error, eof};
alternative(Fs, Obj) -> alternative(Fs, Obj, []).

file(Filename, F) ->
    case file:read_file(Filename) of
        {ok, B} -> string(B, F);
        {error, R} -> error({unreadable, R})
    end.

final({B1, B2}, Obj) when is_binary(B1), is_binary(B2) ->
    Sz = byte_size(B1),
    case Sz =:= byte_size(B2) andalso peek_chars(Obj, Sz) of
        {B0, Sz} when B1 =< B0, B0 =< B2 -> {ok, B0, bump_ptr(Obj, Sz)};
        E -> {error, {miss, E, {B1, B2}}}
    end;
final(Bin, Obj) when is_binary(Bin) ->
    case peek_chars(Obj, byte_size(Bin)) of
        {Bin, Sz} -> {ok, Bin, bump_ptr(Obj, Sz)};
        E -> {error, {miss, E, Bin}}
    end.

repeat(Min, Max, F, Obj) -> repeat(0, Min, minus1(Max), F, Obj, []).

sequence(_, #{ptr := eof}) -> {error, eof};
sequence(Fs, Obj) -> sequence(Fs, Obj, []).

string(L, F) when is_list(L) -> string(list_to_binary(L), F);
string(B, _) when not is_binary(B) -> error({badarg, not_a_string});
string(B, F) ->
    Obj = #{ptr => 0, bin => B, sz => byte_size(B)},
    case F(Obj) of
        {ok, Xs, #{ptr := eof}} -> {ok, Xs, eof};
        {ok, Xs, #{sz := Sz, ptr := Ptr}} -> {ok, Xs, Sz - Ptr};
        {error, R} -> {error, R}
    end.

alternative([], _Obj, Es) -> {error, {fail, Es}};
alternative([F | Fs], Obj, Es) ->
    case F(Obj) of
        {ok, X, O} -> {ok, X, O};
        {error, E} -> alternative(Fs, Obj, [E | Es])
    end.

bump_ptr(Obj, N) ->
    maps:update_with(ptr, fun (Ptr) -> Ptr + N end, Obj).

minus1(inf) -> inf;
minus1(I) -> I - 1.

peek_chars(#{ptr := Ptr, sz := Sz}, Num) when Sz < Ptr + Num ->
    {error, eof};
peek_chars(#{bin := Bin, ptr := Ptr}, N) ->
    {binary:part(Bin, {Ptr, N}), N}.

repeat(N, Mn, Mx, F, Obj, Xs) ->
    case F(Obj) of
        {ok, X, O} when N =:= Mx -> {ok, lists:reverse([X | Xs]), O};
        {ok, X, O} -> repeat(N + 1, Mn, Mx, F, O, [X | Xs]);
        {error, R} when N < Mn -> {error, {too_few, R}};
        {error, _R} -> {ok, lists:reverse(Xs), Obj}
    end.

sequence([], Obj, Xs) ->
    {ok, lists:reverse(Xs), Obj};
sequence([F | Fs], Obj, Xs) ->
    case F(Obj) of
        {ok, X, O} -> sequence(Fs, O, [X | Xs]);
        {error, R} -> {error, {unexpected, R}}
    end.
